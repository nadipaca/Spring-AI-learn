â¤ ğ—ğ—®ğ˜ƒğ—®ğ—¦ğ—°ğ—¿ğ—¶ğ—½ğ˜ ğ—”ğ—±ğ˜ƒğ—®ğ—»ğ—°ğ—²ğ—±
1. How JS engines optimize code (JIT, hidden classes).
2. Prototype chain vs class inheritance.
3. Event delegation at scale.
4. AbortController and request cancellation.
5. WeakMap vs Map, real use cases.
6. How garbage collection works in V8.
7. Cross-tab communication (BroadcastChannel, storage events).
8. Writing a custom Promise implementation (conceptually).

â¤ ğ—¥ğ—²ğ—®ğ—°ğ˜ ğ—œğ—»ğ˜ğ—²ğ—¿ğ—»ğ—®ğ—¹ğ˜€ & ğ—”ğ—¿ğ—°ğ—µğ—¶ğ˜ğ—²ğ—°ğ˜ğ˜‚ğ—¿ğ—²
9. How React Fiber changed rendering.
10. Concurrent rendering, when it helps vs hurts.
11. Batching & scheduling updates.
12. Controlled re-render boundaries.
13. Server Components vs Client Components.
14. Hydration and hydration mismatches.
15. Suspense beyond lazy loading.
16. Building a custom hook library design.

â¤ ğ—£ğ—²ğ—¿ğ—³ğ—¼ğ—¿ğ—ºğ—®ğ—»ğ—°ğ—² ğ——ğ—²ğ—²ğ—½ ğ——ğ—¶ğ˜ƒğ—²
17. CPU vs memory bottlenecks in frontend apps.
18. Profiling with React DevTools & browser Performance tab.
19. Avoiding layout thrashing.
20. Virtualization vs windowing tradeoffs.
21. Preload vs prefetch vs priority hints.
22. Bundle analysis & tree shaking failures.
23. Edge caching vs CDN caching strategies.

â¤ ğ—™ğ—¿ğ—¼ğ—»ğ˜ğ—²ğ—»ğ—± ğ—”ğ—¿ğ—°ğ—µğ—¶ğ˜ğ—²ğ—°ğ˜ğ˜‚ğ—¿ğ—²
24. Monolith vs micro-frontend tradeoffs.
25. State management in large teams.
26. Design system governance.
27. Handling breaking API changes safely.
28. Frontend observability stack.
29. Versioning UI contracts.
30. Multi-tenant frontend apps.
31. Security layers in frontend (XSS, CSP, CSRF).

â¤ ğ—¨ğ—« ğ—˜ğ—»ğ—´ğ—¶ğ—»ğ—²ğ—²ğ—¿ğ—¶ğ—»ğ—´
32. Skeleton vs spinner, when to use which.
33. Optimistic UI architecture.
34. Accessibility beyond aria labels.
35. Perceived performance psychology.
36. Gesture handling in mobile web.

â¤ ğ—§ğ—²ğ˜€ğ˜ğ—¶ğ—»ğ—´ & ğ—¥ğ—²ğ—¹ğ—¶ğ—®ğ—¯ğ—¶ğ—¹ğ—¶ğ˜ğ˜†
37. Flaky test detection strategies.
38. Contract testing between FE & BE.
39. Visual regression testing.
40. Chaos engineering for frontend.
